<html>

<head>
  <meta charset="UTF-8">
  <title>출력결과</title>
</head>

<body>
  <script>
    function solution(arr) {
      /**
      let answer = 0;
      // 내 풀이
      let points = [];

      for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr[i].length; j++) {
          switch (i) {
            case 0:
              switch (j) {
                case 0:
                  if (arr[i][j] > arr[i][j + 1] &&
                    arr[i][j] > arr[i + 1][j]) {
                    points.push([i, j]);
                  }
                  break;
                case arr[i].length - 1:
                  if (arr[i][j] > arr[i][j - 1] &&
                    arr[i][j] > arr[i + 1][j]) {
                    points.push([i, j]);
                  }
                  break;
                default:
                  if (arr[i][j] > arr[i][j - 1] &&
                    arr[i][j] > arr[i][j + 1] &&
                    arr[i][j] > arr[i + 1][j]) {
                    points.push([i, j]);
                  }
                  break;
              }
              break;

            case arr.length - 1:
              switch (j) {
                case 0:
                  if (arr[i][j] > arr[i][j + 1] && // 오
                    arr[i][j] > arr[i - 1][j]) { // 위
                    points.push([i, j]);
                  }
                  break;
                case arr[i].length:
                  if (arr[i][j] > arr[i][j - 1] && // 왼
                    arr[i][j] > arr[i - 1][j]) { // 위
                    points.push([i, j]);
                  }
                  break;
                default:
                  if (arr[i][j] > arr[i][j - 1] && // 왼
                    arr[i][j] > arr[i][j + 1] && // 오
                    arr[i][j] > arr[i - 1][j]) { // 위
                    points.push([i, j]);
                  }
                  break;
              }
              break;

            default:
              switch (j) {
                case 0:
                  if (arr[i][j] > arr[i][j + 1] && // 오
                    arr[i][j] > arr[i + 1][j] && // 아래
                    arr[i][j] > arr[i - 1][j]) { // 위
                    points.push([i, j]);
                  }
                  break;
                case arr[i].length - 1:
                  if (arr[i][j] > arr[i][j - 1] && // 왼
                    arr[i][j] > arr[i + 1][j] && // 아래
                    arr[i][j] > arr[i - 1][j]) { // 위
                    points.push([i, j]);
                  }
                  break;
                default:
                  if (arr[i][j] > arr[i][j - 1] && // 왼
                    arr[i][j] > arr[i][j + 1] && // 오
                    arr[i][j] > arr[i + 1][j] && // 아래
                    arr[i][j] > arr[i - 1][j]) { // 위
                    points.push([i, j]);
                  }
                  break;
              }
              break;
          }
        }
      }

      answer = [...new Set(points)].length;
      /*/
      let answer = 0;
      let n = arr.length;
      // 상, 우, 하, 좌 좌표를 구하기 위한 값
      let dx = [-1, 0, 1, 0];
      let dy = [0, 1, 0, -1];

      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          let flag = true;
          for (let k = 0; k < dx.length; k++) {
            let nx = i + dx[k]; // 탐색하려는 행 좌표
            let ny = j + dy[k]; // 탐색하려는 열 좌표
            // 배열의 인덱스가 음수가 될 수는 없다.
            if (!(0 <= nx && nx < n && 0 <= ny && ny < n)) continue;
            // 주변보다 숫자가 작거나 같으면 봉우리가 아님
            if (arr[nx][ny] >= arr[i][j]) {
              flag = false;
              break;
            }
          }
          if (flag) answer++;
        }
      }
      /**/
      return answer;
    }

    let arr = [
      [5, 3, 7, 2, 3],
      [3, 7, 1, 6, 1],
      [7, 2, 5, 3, 4],
      [4, 3, 6, 4, 1],
      [8, 7, 3, 5, 2]
    ];
    console.log(solution(arr));
  </script>
</body>

</html>